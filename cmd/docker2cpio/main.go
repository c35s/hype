// docker2cpio receives a tar archive generated by "docker image save" as input
// and outputs a corresponding cpio archive. To examine it, try
//
//	docker image save IMAGE |  docker2cpio | cpio -itv".
//
// Only a single image is supported. Only regular files, symlinks, and
// directories are supported. Hardlinks, char/block special files, and fifos
// are skipped.
package main

import (
	"archive/tar"
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"os"

	"github.com/cavaliergopher/cpio"
)

func main() {
	in := tar.NewReader(os.Stdin)
	out := cpio.NewWriter(os.Stdout)

	type entry struct {
		Hdr *tar.Header
		Buf *bytes.Buffer
	}

	docker := make(map[string]entry)

	for {
		hdr, err := in.Next()
		if err == io.EOF {
			break
		}

		if err != nil {
			panic(err)
		}

		buf := new(bytes.Buffer)
		if _, err := io.Copy(buf, in); err != nil {
			panic(err)
		}

		docker[hdr.Name] = entry{
			Hdr: hdr,
			Buf: buf,
		}
	}

	var manifest []struct {
		Layers []string
	}

	if err := json.Unmarshal(docker["manifest.json"].Buf.Bytes(), &manifest); err != nil {
		panic(err)
	}

	for _, image := range manifest {
		for _, name := range image.Layers {
			r := tar.NewReader(docker[name].Buf)
			for {
				th, err := r.Next()
				if err == io.EOF {
					break
				}

				if err != nil {
					panic(err)
				}

				ch := cpio.Header{
					Name:    th.Name,
					Size:    th.Size,
					Mode:    cpio.FileMode(th.FileInfo().Mode().Perm()),
					Uid:     th.Uid,
					Guid:    th.Gid,
					ModTime: th.ModTime,
				}

				switch th.Typeflag {
				case tar.TypeReg:
					ch.Mode |= cpio.TypeReg
					if err := out.WriteHeader(&ch); err != nil {
						panic(err)
					}
					if _, err := io.Copy(out, r); err != nil {
						panic(err)
					}

				case tar.TypeLink:
					fmt.Fprintf(os.Stderr, "docker2cpio: skipping hardlink: name=%s linkname=%s\n", th.Name, th.Linkname)

				case tar.TypeSymlink:
					ch.Mode |= cpio.TypeSymlink
					ch.Size = int64(len(th.Linkname))
					if err := out.WriteHeader(&ch); err != nil {
						panic(err)
					}
					if _, err := out.Write([]byte(th.Linkname)); err != nil {
						panic(err)
					}

				case tar.TypeChar:
					fmt.Fprintf(os.Stderr, "docker2cpio: skipping character node: name=%s\n", th.Name)

				case tar.TypeBlock:
					fmt.Fprintf(os.Stderr, "docker2cpio: skipping block node: name=%s\n", th.Name)

				case tar.TypeDir:
					ch.Mode |= cpio.TypeDir
					if err := out.WriteHeader(&ch); err != nil {
						panic(err)
					}

				case tar.TypeFifo:
					fmt.Fprintf(os.Stderr, "docker2cpio: skipping fifo: name=%s\n", th.Name)

				default:
					panic(fmt.Errorf("unknown typeflag: %v", th.Typeflag))
				}

			}
		}
	}

	if err := out.Close(); err != nil {
		panic(err)
	}
}

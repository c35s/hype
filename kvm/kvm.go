//go:build linux

//go:generate go run ../cmd/kvm-gen-magic -out magic.go -pkg kvm

// Package kvm provides minimal wrappers for some KVM ioctls. It is pure Go: Instead of
// using Cgo to include linux/kvm.h, the package includes a magic.go file generated by
// kvm-gen-magic.
//
// Passages from kvm/api.txt are marked with double quotes in the function docs.
//
// https://www.kernel.org/doc/Documentation/virtual/kvm/api.txt
// https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/uapi/linux/kvm.h
// https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/arch/x86/include/uapi/asm/kvm.h
package kvm

import (
	"fmt"
	"os"
	"unsafe"

	"golang.org/x/sys/unix"
)

// VM is a virtual machine file descriptor.
type VM struct {
	*os.File
}

// VCPU is a virtual CPU file descriptor.
type VCPU struct {
	*os.File
}

// Cap is a KVM_CHECK_EXTENSION identifier.
type Cap int

// Exit is a KVM_RUN exit reason.
type Exit uint32

// UserspaceMemoryRegion has the same layout as the C struct kvm_userspace_memory_region.
type UserspaceMemoryRegion struct {
	Slot          uint32
	Flags         uint32
	GuestPhysAddr uint64
	MemorySize    uint64
	UserspaceAddr uint64
}

// IRQFDConfig has the same layout as struct kvm_irqfd.
type IRQFDConfig struct {
	Fd         uint32
	GSI        uint32
	Flags      uint32
	ResampleFD uint32
	_          [16]uint8
}

// StableAPIVersion is the expected return value of GetAPIVersion.
const StableAPIVersion = 12

// GetAPIVersion returns the KVM API version, normally StableAPIVersion.
func GetAPIVersion(sys *os.File) (int, error) {
	v, _, errno := unix.Syscall(unix.SYS_IOCTL, sys.Fd(), kGetAPIVersion, 0)
	if errno != 0 {
		return 0, errno
	}

	return int(v), nil
}

// CreateVM creates a new VM and returns its file descriptor.
func CreateVM(sys *os.File) (*VM, error) {
	fd, _, errno := unix.Syscall(unix.SYS_IOCTL, sys.Fd(), kCreateVM, 0)
	if errno != 0 {
		return nil, errno
	}

	// FIX: cloexec?
	return &VM{os.NewFile(fd, "vm")}, nil
}

// CheckExtension returns a non-zero value if the extension identified by the given
// capability is available. "Generally 0 means no and 1 means yes, but some extensions may
// report additional information in the integer return value."
//
// If CheckExtension(dev, CapCheckExtensionVM) returns 1, then CheckExtension can also be
// used to test VM extensions.
func CheckExtension(f interface{ Fd() uintptr }, cap Cap) (int, error) {
	v, _, errno := unix.Syscall(unix.SYS_IOCTL, f.Fd(), kCheckExtension, uintptr(cap))
	if errno != 0 {
		return 0, errno
	}

	return int(v), nil
}

// AllCaps returns a slice containing all known extension identifiers.
func AllCaps() []Cap {
	caps := make([]Cap, len(allCaps))
	copy(caps, allCaps)
	return caps
}

// GetVCPUMmapSize returns the byte size of the shared memory region used by the KVM_RUN ioctl.
func GetVCPUMmapSize(sys *os.File) (int, error) {
	sz, _, errno := unix.Syscall(unix.SYS_IOCTL, sys.Fd(), kGetVCPUMmapSize, 0)
	if errno != 0 {
		return 0, errno
	}

	return int(sz), nil
}

// CreateVCPU adds a VCPU to the given VM. It returns the new VCPU's file descriptor. The
// given id identifies the VCPU within the VM. Normally the first VCPU has id 0, the
// second has id 1, and so on.
func CreateVCPU(vm *VM, id int) (*VCPU, error) {
	fd, _, errno := unix.Syscall(unix.SYS_IOCTL, vm.Fd(), kCreateVCPU, uintptr(id))
	if errno != 0 {
		return nil, errno
	}

	// FIX: cloexec?
	return &VCPU{os.NewFile(fd, fmt.Sprintf("vcpu-%d", id))}, nil
}

// Run runs the given vcpu. It returns EINTR if "an unmasked signal is pending".
func Run(vcpu *VCPU) error {
	_, _, errno := unix.Syscall(unix.SYS_IOCTL, vcpu.Fd(), kRun, 0)
	if errno != 0 {
		return errno
	}

	return nil
}

// SetUserMemoryRegion "allows the user to create, modify or delete a guest physical
// memory slot." This ioctl is available if CheckExtension(CapUserMemory) returns 1.
func SetUserMemoryRegion(vm *VM, region *UserspaceMemoryRegion) error {
	_, _, errno := unix.Syscall(unix.SYS_IOCTL, vm.Fd(), kSetUserMemoryRegion, uintptr(unsafe.Pointer(region)))
	if errno != 0 {
		return errno
	}

	return nil
}

// CreateIRQChip "creates an interrupt controller model in the kernel."
// This ioctl is available if CheckExtension(CapIRQChip) returns 1.
func CreateIRQChip(vm *VM) error {
	_, _, errno := unix.Syscall(unix.SYS_IOCTL, vm.Fd(), kCreateIRQChip, 0)
	if errno != 0 {
		return errno
	}

	return nil
}

// IRQFD "allows setting an eventfd to directly trigger a guest interrupt. IRQFDConfig.Fd
// specifies the file descriptor to use as the eventfd and IRQFDConfig.GSI specifies the
// irqchip pin toggled by this event. When an event is triggered on the eventfd, an
// interrupt is injected into the guest using the specified gsi pin. The irqfd is removed
// using the KVM_IRQFD_FLAG_DEASSIGN flag, specifying both IRQFDConfig.Fd and
// IRQFDConfig.GSI."
func IRQFD(vm *VM, cfg *IRQFDConfig) error {
	_, _, errno := unix.Syscall(unix.SYS_IOCTL, vm.Fd(), kIRQFD, uintptr(unsafe.Pointer(cfg)))
	if errno != 0 {
		return errno
	}

	return nil
}
